<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>

</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@5"></script><script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.7.10/dist/browser/view.min.js"></script><script>((data, init, items, opts) => {
        const {
          Markmap,
          loadPlugins
        } = window.markmap;
        (init ? init(loadPlugins, items, opts) : Promise.resolve()).then(() => {
          Markmap.create('svg#mindmap', null, data);
        });
      })({"t":"heading","d":1,"v":"Go语言设计与实现003","c":[{"t":"list_item","d":2,"v":"Go语言是一个需要编译才能运行的编程语言，也就是说代码在运行之前就需要通过编译器生成二进制机器码，包含二进制机器码的文件才能在目标及其上运行"},{"t":"list_item","d":2,"v":"编译原理","c":[{"t":"list_item","d":3,"v":"预备知识","c":[{"t":"list_item","d":4,"v":"抽象语法树","c":[{"t":"list_item","d":5,"v":"抽象语法树（AST，Abstrat Syntax Tree），是源代码语法的结构的一种抽象表示，它用树状的方式表示编程语言的语法结构。抽象语法树的每一个节点都表示源代码中元素，每一个子树都表示一个语法元素。"},{"t":"list_item","d":5,"v":"作为编译器常用的数据结构，抽象语法树抹去了源代码中不重要的一些字符、空格、分号或者括号。编译器在执行完语法分析之后会输出一个抽象语法树。这个抽象语法树会辅助编译器进行语义分析，可以用他来确定语法正确的程序是否存在一些类型不匹配或者不一致的问题"}]},{"t":"list_item","d":4,"v":"静态单赋值","c":[{"t":"list_item","d":5,"v":"静态单赋值（SSA，Static Single Assignment）是中间代码的一个特性，如果一个中间代码具有静态赋值的特性，那么每个变量就只会被赋值一次。"},{"t":"list_item","d":5,"v":"当我们在使用具有 SSA 特性的中间代码时，就可以非常清晰的发现变量的关系"},{"t":"list_item","d":5,"v":"在中间代码中使用 SSA 的特性能够为整个程序实现以下几个优化：","c":[{"t":"list_item","d":6,"v":"常数传播"},{"t":"list_item","d":6,"v":"值域传播"},{"t":"list_item","d":6,"v":"稀疏有条件的常数传播"},{"t":"list_item","d":6,"v":"消除无用的程式码"},{"t":"list_item","d":6,"v":"全域数值编号"},{"t":"list_item","d":6,"v":"消除部分的冗余"},{"t":"list_item","d":6,"v":"强度折减"},{"t":"list_item","d":6,"v":"寄存器分配"}]},{"t":"list_item","d":5,"v":"由于SSA的主要作用是对代码进行优化，所以他是编译器后端的一部分。当然代码编译领域除了SSA还有很多中间代码的优化方法。<strong>编译器生成代码的优化也是一个非常古老且复杂的领域</strong>"}]},{"t":"list_item","d":4,"v":"指令集","c":[{"t":"list_item","d":5,"v":"x86是目前比较常见的指令集，除了x86之外，还有很多其他的指令集，不同的处理器使用不同的架构和机器语言，所以很多编程语言为了在不同的机器上运行需要将源代码根据架构翻译成不同的机器代码"},{"t":"list_item","d":5,"v":"复杂指令集计算机（CISC）和精简指令集计算机（RISC）是目前的两种 CPU 区别","c":[{"t":"list_item","d":6,"v":"复杂指令集通过增加指令的数量减少需要执行的指令数"},{"t":"list_item","d":6,"v":"精简指令集能使用更少的指令完成目标的计算任务"}]}]}]},{"t":"list_item","d":3,"v":"编译原理","c":[{"t":"list_item","d":4,"v":"Go 语言编译器的源代码在 <code>src/cmd/compile</code> 目录中，目录下的文件共同组成了 Go 语言的编译器"},{"t":"list_item","d":4,"v":"编译器的前端和后端","c":[{"t":"list_item","d":5,"v":"编译器的前端一般承担着词法分析、语法分类、类型检查和中间代码生成几个步骤"},{"t":"list_item","d":5,"v":"编译器的后端主要负责目标代码的生成和优化，也就是将中间代码翻译成目标及其能够运行的二进制机器码"}]},{"t":"list_item","d":4,"v":"Go 的编译器在逻辑上可以分成四段：词法与语法分析、类型检查和AST转换、通过 SSA生成和最后的机器代码生成"},{"t":"list_item","d":4,"v":"词法与语法分析"}]}]}]})</script>
</body>
</html>
